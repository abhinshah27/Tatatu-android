package rs.highlande.app.tatatu.connection.webSocket

import android.os.Bundle
import com.google.gson.JsonArray
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject
import org.koin.core.KoinComponent
import rs.highlande.app.tatatu.BuildConfig
import rs.highlande.app.tatatu.connection.OnServerMessageReceivedListener
import rs.highlande.app.tatatu.connection.getNewIdOperation
import rs.highlande.app.tatatu.core.util.JsonToSerialize
import rs.highlande.app.tatatu.core.util.LogUtils
import java.lang.ref.WeakReference

enum class RequestStatus { SENT, ERROR, NO_CONNECTION }

/**
 * Class holding reference to a request generated by the client and addressed to HL WebSocket Server.
 * @param bundles vararg with the various instances of [Bundle] to be inserted in JSON.
 * @param callCode the number indicating the scope of the request.
 * @param logTag string tag for logging.
 * @param name string referring to the area of the call (internal to the DB).
 * @param dbName name of the DB.
 * @param caller instance of [OnServerMessageReceivedListener] calling and to which data is forwarded after receiving
 * response.
 * @param isChat whether the request is related to a chat-based operation or not.
 */
class SocketRequest(
    vararg bundles: Bundle?,
    callCode: Int,
    logTag: String,
    name: String = SERVER_CODE_NAME,
    dbName: String = SERVER_CODE_DB_NAME,
    caller: OnServerMessageReceivedListener?,
    val isChat: Boolean = false
) : KoinComponent {

    private val caller: WeakReference<OnServerMessageReceivedListener?> = WeakReference(caller)

    lateinit var id: String
    lateinit var body: String

    init {
        buildMessageJson(bundles = *bundles, opCode = callCode, logTag = logTag, name = name, dbName = dbName)
    }


    val isValid: Boolean
        get() = (caller.get() != null) && !body.isBlank()

    fun getCaller() = caller.get()

    /**
     * Builds the default bridge communication structure between server and client.
     *
     * @param bundles vararg pointing to the series of [Bundle]s needed to populate request's body.
     * @param opCode the code of the action performed.
     * @param logTag the prefix tag for logging.
     * @param name the server name.
     * @param dbName the database name.
     *
     * @throws JSONException if something goes wrong during the operation.
     */
    @Throws(JSONException::class)
    private fun buildMessageJson(
        vararg bundles: Bundle?,
        opCode: Int,
        logTag: String,
        name: String,
        dbName: String
        //        , saveUUIDForNotification: Boolean        // TODO: 2019-07-11    check if still necessary with new logics
    ): String {

        val json = JSONObject()

        val event = JSONObject()
        id = getNewIdOperation()
        event.put("idOperation", id)
            .put("action", opCode)
        if (!name.isBlank())
            event.put("name", name)
        if (!dbName.isBlank())
            event.put("dbName", dbName)
        // default value
        event.put("collection", "")
        event.put("v", BuildConfig.BASE_VERSION_NAME)
        json.put("event", event)

        val objects = JSONArray()
        if (!bundles.isNullOrEmpty()) {
            for (bundle in bundles) {
                val obj = JSONObject()
                bundle?.let {
                    for (innerKey in it.keySet()) {

                        // handles JsonToSerialize implementations
                        when {
                            it[innerKey] is JsonToSerialize -> {
                                val j = (it[innerKey] as JsonToSerialize).serializeToJsonObject()
                                for (key in j.keys()) {
                                    obj.put(key, j.opt(key))
                                }
                            }
                            //handles case when bundle element is a list
                            it[innerKey] is List<*> -> {
                                val list = it[innerKey] as List<*>
                                obj.put(innerKey, JSONArray().apply {
                                    list.forEach {value ->
                                        this.put(value)
                                    }
                                })
                            }
                            else -> obj.put(innerKey, it[innerKey])
                        }

                    }
                    objects.put(obj)
                }
            }
        }


        json.put("objects", objects)

        LogUtils.d(logTag, "with body: $json")

        //        if (saveUUIDForNotification)
        //            HLNotifications.getInstance().addRequestUUID(idOp)

        body = json.toString()


        return body
    }


}


/**
 * Class holding reference to a response generated by the HL WebSocket Server.
 * @param body the string representation of the response itself.
 */
class SocketResponse(body: String?) {

    lateinit var id: String
    var callCode: Int? = null
    var jsonResponse: JSONArray? = null
    lateinit var error: Pair<Int, String>

    val isValid get() = !id.isBlank() && (jsonResponse != null)

    // TODO: 2019-07-12    check if it's till valid
    val isError get() = error.first > -1

    val is401Error get() = error.first == 3999 && error.second.contains("401")


    init {
        parseJsonResponse(body)
    }


    /**
     * Parses string result sent from server for client.
     *
     * @param body the [String] object received from server.
     *
     * @throws JSONException if something goes wrong during the operation.
     */
    @Throws(JSONException::class)
    private fun parseJsonResponse(body: String?) {
        if (!body.isNullOrBlank()) {
            val jsonMessage = JSONObject(body)

            val event = jsonMessage.optJSONObject("event")
            jsonResponse = jsonMessage.optJSONArray("results")

            callCode = event!!.optInt("action")
            id = event.optString("idOperation")

            val obj: JSONObject
            var statusCode = -1
            var description = ""
            if (jsonResponse != null && jsonResponse!!.length() > 0) {
                obj = jsonResponse!!.optJSONObject(0)
                statusCode = obj.optInt("responseStatus", -1)
                description = obj.optString("description", "")
            }
            error = statusCode to description
        }
    }

    companion object {

        fun is401Error(code: Int, description: String?) = code == 3999 && description?.contains("401") ?: false

    }

}